{"version":3,"sources":["horas.js","tags.js"],"names":["document","querySelector","busqueda","categoria_id","dia","categoria","dias","querySelectorAll","terminoBusqueda","e","target","name","value","Object","values","includes","async","url","resultado","fetch","json","buscarEventos","addEventListener","forEach","tagsInput","tags","tagsDiv","tagsInputHidden","mostrarTags","textContent","tag","etiqueta","createElement","classList","add","ondblclick","eliminarTag","appendChild","actualizarInputHidden","remove","filter","toString","split","keyCode","trim","preventDefault"],"mappings":"CAGA,WAKA,GAHAA,SAAAC,cAAA,UAGA,CAGA,IAAAC,EAAA,CACAC,aAAA,GACAC,IAAA,IAKA,MAAAC,EAAAL,SAAAC,cAAA,yBAIAK,EAAAN,SAAAO,iBAAA,gBAEAP,SAAAC,cAAA,mBAWA,SAAAO,EAAAC,GAMAP,EAAAO,EAAAC,OAAAC,MAAAF,EAAAC,OAAAE,MAKAC,OAAAC,OAAAZ,GAAAa,SAAA,KASAC,iBAGA,MAAAZ,IAAAA,EAAAD,aAAAA,GAAAD,EAEAe,EAAA,+BAAAb,kBAAAD,IAGAe,QAAAC,MAAAF,SAEAC,EAAAE,OAdAC,GAxBAhB,EAAAiB,iBAAA,SAAAd,GAIAF,EAAAiB,QAAAnB,GAAAA,EAAAkB,iBAAA,SAAAd,KA5BA,GCAA,WAEA,MAAAgB,EAAAxB,SAAAC,cAAA,eAGA,GAAAuB,EAAA,CAGA,IAAAC,EAAA,GAGA,MAAAC,EAAA1B,SAAAC,cAAA,SAIA0B,EAAA3B,SAAAC,cAAA,iBA8CA,SAAA2B,IAEAF,EAAAG,YAAA,GAIAJ,EAAAF,QAAAO,IAEA,MAAAC,EAAA/B,SAAAgC,cAAA,MAEAD,EAAAE,UAAAC,IAAA,mBAEAH,EAAAF,YAAAC,EAEAC,EAAAI,WAAAC,EAEAV,EAAAW,YAAAN,KAIAO,IAIA,SAAAF,EAAA3B,GAEAA,EAAAC,OAAA6B,SAGAd,EAAAA,EAAAe,OAAAV,GAAAA,IAAArB,EAAAC,OAAAmB,aAEAS,IAKA,SAAAA,IAEAX,EAAAf,MAAAa,EAAAgB,WAhFA,KAAAd,EAAAf,QAGAa,EAAAE,EAAAf,MAAA8B,MAAA,KAEAd,KAIAJ,EAAAF,iBAAA,YAGA,SAAAb,GAGA,GAAA,KAAAA,EAAAkC,QAAA,CAIA,GAAA,KAAAlC,EAAAC,OAAAE,MAAAgC,QAAAnC,EAAAC,OAAAE,MAAA,EACA,OAKAH,EAAAoC,iBAMApB,EAAA,IAAAA,EAAAhB,EAAAC,OAAAE,MAAAgC,QAGApB,EAAAZ,MAAA,GAGAgB,SAxDA","file":"bundle.js","sourcesContent":["//el código js irá dentro de una función IIFE (Inmediately Invoked Function Expresión), \r\n//esta función se autoejecuta inmediatamente despues de ser definida.\r\n//Se usa para evitar la contaminación del ámbito global y encapsular sus variables.\r\n(function() {\r\n    //seleciona elemento html del form con id = horas\r\n    const horas = document.querySelector('#horas');\r\n\r\n    //si existe el elemento horas, ejecuta el código\r\n    if(horas) {\r\n\r\n        //objeto para almacenar temporalmente, la categoria y el dia seleccionados en el form\r\n        let busqueda = {\r\n            categoria_id: '',\r\n            dia: ''\r\n        }\r\n\r\n        //selecciona el elemento html cuyo atributo name=\"categoria_id\",\r\n        //el select de categoria del fomrulario\r\n        const categoria = document.querySelector('[name=\"categoria_id\"]');\r\n        //selecciona todos elementos html cuyo atributo name=\"dia\",\r\n        //son todas las opciones del input type radio, obtenidas de la var $dias,\r\n        //que contiene los elementos con id 1 Viernes y 2 Sábado, de la tabla dias, de la DB\r\n        const dias = document.querySelectorAll('[name=\"dia\"]');\r\n        //selecciona elemento html cuyo atributo name=\"dia_id\". El input oculto.\r\n        const inputHiddenDia = document.querySelector('[name=\"dia_id\"]');\r\n        \r\n        //asigna escuchador de evento change y función, al select de categoría del formulario\r\n        categoria.addEventListener('change', terminoBusqueda);\r\n        \r\n        //itera los dias, para poder asignar un escuchador de evento (change) y una función,\r\n        //a cada elemento dia de dias.\r\n        dias.forEach(dia => dia.addEventListener('change', terminoBusqueda));\r\n\r\n        //función terminoBusqueda que recibe eventos en (e),\r\n        //tanto de categoria como de dia\r\n        function terminoBusqueda(e){\r\n            //asigna, a la propiedad del objeto busqueda, cuya clave es igual al valor del atributo .name,\r\n            //del elemento e.target que origina el evento e,  \r\n            //le asigna el valor del atributo .value, del elemento e.target que origina el evento e. \r\n            //Resumiendo, a la propiedad categoria_id del objeto busqueda, le asigna ó 1 ó 2 (ó Conferenica ó Workshop), \r\n            //y a la propiedad dia del objeto busqueda, le asigna ó 1 ó 2 (ó Viernes ó Sabado),\r\n            busqueda[e.target.name] = e.target.value;\r\n\r\n            //La API requiere como argumentos, dia_id y categoria_id, que obtendremos del objeto busqueda. \r\n            //Validar que no están vacios, antes de llamar a la funcion que consulta a la API.\r\n            //Si alguno de los values (atributos) del Objeto busqueda contiene '' strinc vacio, para el código\r\n            if(Object.values(busqueda).includes('')) {\r\n                return;\r\n            }\r\n\r\n            //llama a la función que consulta a la API\r\n            buscarEventos();\r\n        }\r\n\r\n        //función que consulta a la API APIEventos.php, a través del endpoint /api/eventos-horario\r\n        async function buscarEventos() {\r\n\r\n            //deconstrucción del objeto busqueda, en dos variables con sus valores\r\n            const { dia, categoria_id} = busqueda\r\n            //define url para la consulta, incluyendo query string ? con los parametros para la API, \r\n            const url = `/api/eventos-horario?dia_id=${dia}&categoria_id=${categoria_id}`;\r\n           \r\n            //consulta fetch a la ulr de la API\r\n            const resultado = await fetch(url);\r\n            //obtiene eventos como resultado json\r\n            const eventos = await resultado.json();\r\n\r\n            obtenerHorasDisponibles()\r\n        }\r\n\r\n        function obtenerHorasDisponibles() {\r\n            \r\n        }\r\n    }\r\n})();","//el código js irá dentro de una función IIFE (Inmediately Invoked Function Expresión), \r\n//esta función se autoejecuta inmediatamente despues de ser definida.\r\n//Se usa para evitar la contaminación del ámbito global y encapsular sus variables.\r\n(function() {\r\n    //selecciona el elemento con id #tags_input y la asigna a la var tagsInput\r\n    const tagsInput = document.querySelector('#tags_input');\r\n    \r\n    //si el elemento tagsInput existe, se ejecuta el código\r\n    if(tagsInput) {\r\n        \r\n        //arreglo almacena las etiquetas tecleadas en el input, cuando se teclee ,\r\n        let tags = [];\r\n\r\n        //selecciona elemento html con id #tags, donde se mostraran los tags\r\n        const tagsDiv = document.querySelector('#tags');\r\n\r\n        //selecciona elemento html del form, con el atributo name=\"tags\"\r\n        //es el input hidden (oculto) del formulario agregar ponentes\r\n        const tagsInputHidden = document.querySelector('[name=\"tags\"]');\r\n\r\n        //**Recuperar los tags del value del input hidden (oculto)\r\n        //si el atributo value de elemento tagsInputHidden, contiene info\r\n        if(tagsInputHidden.value !== '') {\r\n            //extrae los valores separados por ',' del string, \r\n            //los convierte en arreglo y los asigna a tags\r\n            tags = tagsInputHidden.value.split(',');\r\n            //llama metodo que muestra los tags en el formulario\r\n            mostrarTags()\r\n        }\r\n\r\n        //Escuchar cambios en el input, cuando se teclee algo, ejecuta función\r\n        tagsInput.addEventListener('keypress', guardarTag);\r\n\r\n        //función que recibe el evento escuchado en e\r\n        function guardarTag(e) {\r\n            //si el código de la tecla que dispara el evento e, es 44\r\n            //significa que la tecla es una coma ,\r\n            if(e.keyCode === 44) {\r\n\r\n                //validar si se teclean espacios en blanco, o no se ha tecleado nada,\r\n                //no seguir ejecutando el código\r\n                if(e.target.value.trim() === '' || e.target.value < 1) {\r\n                    return\r\n                }\r\n\r\n                //cuando se ha pulsado la coma, evita la acción por defecto del evento e\r\n                // que es escribir la coma, para que la coma , no se muestre en el input\r\n                e.preventDefault();\r\n\r\n                //como se ha pulsado la tecla coma ,\r\n                //se genera un nuevo arreglo que toma copia del arreglo tags ...tags,\r\n                //agrega el valor de lo que se haya tecleado en el input (e.target.value),\r\n                //eliminando los valores en blanco con .trim() y lo reasigna al arreglo tags\r\n                tags = [...tags, e.target.value.trim()];\r\n                \r\n                //limpia el contenido del input tagsInput, tras pulsar la coma ,\r\n                tagsInput.value = '';\r\n\r\n                //llama función mostra los tags\r\n                mostrarTags();\r\n            }\r\n        }\r\n\r\n        //Muestra cada tag en el formulario\r\n        function mostrarTags() {\r\n            //agrega al div un string vacio, para limpiar\r\n            tagsDiv.textContent = '';\r\n\r\n            //itera el arreglo tags con las etiquetas introducidas\r\n            //y por cada etiqueta en tag\r\n            tags.forEach( tag => {\r\n                //crea un elemento LI y lo asigna a etiqueta\r\n                const etiqueta = document.createElement('LI');\r\n                //agrega la clase formulario__tag al elemento LI\r\n                etiqueta.classList.add('formulario__tag');\r\n                //agrega el valor (string) de la etiqueta iterada, en tag, al LI etiqueta\r\n                etiqueta.textContent = tag;\r\n                //asigna evento dobleclick a la etiqueta, que ejecutará la función eliminarTag\r\n                etiqueta.ondblclick = eliminarTag\r\n                //inserta el LI etiqueta, como hijo del div con id #tags\r\n                tagsDiv.appendChild(etiqueta); \r\n            })\r\n\r\n            //llama la función que asigna, el tag mostrado, al input hidden (oculto)\r\n            actualizarInputHidden()\r\n        }\r\n\r\n        //elimina del DOM y del arreglo tags, el tag recibido como evento dobleclick en e,\r\n        function eliminarTag(e) {\r\n            //elimina del DOM, el elemento (tag) que origna el evento e, el e.target\r\n            e.target.remove()\r\n            //filtra y obtiene cada tag sobre el que no se haya aplicado el e.target,\r\n            //los no eliminados y los reasigna al arreglo tags\r\n            tags = tags.filter(tag => tag !== e.target.textContent)\r\n            //llama método que asigna los tags al value del input hidden, para la DB\r\n            actualizarInputHidden()\r\n        } \r\n\r\n        //función que asigna cada tag, al value de input hidden (oculto)\r\n        //para actualizarlos en la DB\r\n        function actualizarInputHidden() {\r\n            //asigna al value del input hidden, el arreglo tag convertido a string\r\n            tagsInputHidden.value = tags.toString();\r\n        }\r\n    }\r\n\r\n})();\r\n"]}