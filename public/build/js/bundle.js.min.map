{"version":3,"sources":["horas.js","ponentes.js","tags.js"],"names":["document","querySelector","categoria","dias","querySelectorAll","inputHiddenDia","inputHiddenHora","addEventListener","terminoBusqueda","forEach","dia","busqueda","categoria_id","value","e","target","name","horaPrevia","classList","remove","Object","values","includes","buscarEventos","async","url","resultado","fetch","eventos","listadoHoras","li","add","horasTomadas","map","evento","hora_id","listadoHorasArray","Array","from","filter","dataset","horaId","hora","seleccionarHora","obtenerHorasDisponibles","json","id","horaSeleccionada","onclick","ponentesInput","ponentes","ponentesFiltrados","listadoPonentes","ponenteHidden","seleccionarPonente","ponente","ponentePrevio","ponenteId","respuesta","arrayPonentes","nombre","trim","apellido","formatearPonentes","obtenerPonentes","length","expresion","RegExp","normalize","replace","toLowerCase","search","firstChild","removeChild","ponenteHTML","createElement","textContent","appendChild","noResultados","mostrarPonentes","obtenerPonente","ponenteDOM","tagsInput","tags","tagsDiv","tagsInputHidden","mostrarTags","tag","etiqueta","ondblclick","eliminarTag","actualizarInputHidden","toString","split","keyCode","preventDefault"],"mappings":"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","file":"bundle.js","sourcesContent":["//el código js irá dentro de una función IIFE (Inmediately Invoked Function Expresión), \r\n//esta función se autoejecuta inmediatamente despues de ser definida.\r\n//Se usa para evitar la contaminación del ámbito global y encapsular sus variables.\r\n(function() {\r\n    //seleciona elemento html del form con id = horas\r\n    const horas = document.querySelector('#horas');\r\n\r\n    //si existe el elemento horas, ejecuta el código\r\n    if(horas) {\r\n\r\n        //selecciona el elemento html cuyo atributo name=\"categoria_id\",\r\n        //el select de categoria del fomrulario\r\n        const categoria = document.querySelector('[name=\"categoria_id\"]');\r\n        //selecciona todos elementos html cuyo atributo name=\"dia\",\r\n        //son todas las opciones del input type radio, obtenidas de la var $dias,\r\n        //que contiene los elementos con id 1 Viernes y 2 Sábado, de la tabla dias, de la DB\r\n        const dias = document.querySelectorAll('[name=\"dia\"]');\r\n\r\n        //selecciona elemento html cuyo atributo name=\"dia_id\". El input oculto.\r\n        const inputHiddenDia = document.querySelector('[name=\"dia_id\"]');\r\n        //selecciona elemento html cuyo atributo name=\"hora_id\". El input oculto.\r\n        const inputHiddenHora = document.querySelector('[name=\"hora_id\"]');\r\n\r\n        //asigna escuchador de evento change y función, al select de categoría del formulario\r\n        categoria.addEventListener('change', terminoBusqueda);\r\n        \r\n        //itera los dias, para poder asignar un escuchador de evento (change) y una función,\r\n        //a cada elemento dia de dias.\r\n        dias.forEach(dia => dia.addEventListener('change', terminoBusqueda));\r\n\r\n\r\n        //objeto para almacenar temporalmente, la categoria y el dia seleccionados en el form\r\n        let busqueda = {\r\n            //asigna a categoria_id, el valor (numérico +) de su value, si ya lo tiene, si no ||, no asigna nada ''\r\n            categoria_id: +categoria.value || '',\r\n            //asigna a dia, el valor (numérico +) del value del input, si ya lo tiene, si no ||, no asigna nada ''\r\n            dia: +inputHiddenDia.value || ''\r\n        }\r\n        \r\n        //validar, que las propiedades del objeto busqueda contiene info,\r\n        //Si los values de las propiedades del Objeto busqueda, ! NO contiene '' string vacio,\r\n        //significa que tienen información, esto ocurre cuando los estamos editanto, no cuando se crean\r\n        if(!Object.values(busqueda).includes('')) {\r\n\r\n            //función IIFE que se autoejecuta, con una función anónima asyncrona, para poder usar await\r\n            (async () => {\r\n\r\n                //llama método que busca eventos según la categoria_id y el dia, consultando a la API,\r\n                //y a su vez obtiene las horas disponibles y ocupadas.\r\n                //await hace que se ejecute completamente la función, antes de continuar con el código siguiente\r\n                await buscarEventos();\r\n\r\n                //obtiene el valor del value de inputHiddenHora y lo asigna a id\r\n                const id = inputHiddenHora.value;\r\n                \r\n                //** Resaltar la hora seleccionada para el evento con esta categoria_id y dia,\r\n                //** el evento que estamos editando.\r\n                //obtiene el elemento html cuyo atributo personalizado data-hora-id = al value del inputHiddenHora, en id\r\n                const horaSeleccionada = document.querySelector(`[data-hora-id=\"${id}\"]`);\r\n                //elimina la clase horas__hora--deshabilitada a la hora del elemento que estamos editando\r\n                horaSeleccionada.classList.remove('horas__hora--deshabilitada');\r\n                horaSeleccionada.classList.add('horas__hora--seleccionada');\r\n\r\n                //permite volver a seleccionar la hora que ya estaba seleccionada inicialmente\r\n                horaSeleccionada.onclick = seleccionarHora;\r\n\r\n            })();\r\n        }\r\n\r\n        //función terminoBusqueda que recibe eventos en (e),\r\n        //tanto de categoria como de dia\r\n        function terminoBusqueda(e){\r\n            //asigna, a la propiedad del objeto busqueda, cuya clave es igual al valor del atributo .name,\r\n            //del elemento e.target que origina el evento e,  \r\n            //le asigna el valor del atributo .value, del elemento e.target que origina el evento e. \r\n            //Resumiendo, a la propiedad categoria_id del objeto busqueda, le asigna ó 1 ó 2 (ó Conferenica ó Workshop), \r\n            //y a la propiedad dia del objeto busqueda, le asigna ó 1 ó 2 (ó Viernes ó Sabado),\r\n            busqueda[e.target.name] = e.target.value;\r\n\r\n            //**Una vez almacenados en busqueda, la categoría y o el día, seleccionados, y antes buscar eventos:\r\n            //Reiniciar el value de los campos input ocultos, del form: \r\n            inputHiddenHora.value = '';\r\n            inputHiddenDia.value = '';\r\n            //Reinicia la clase de las horas seleccionadas, del form:\r\n            //selecciona el elemento (li) con clase .horas__hora--seleccionada\r\n            const horaPrevia = document.querySelector('.horas__hora--seleccionada');\r\n            //si existe algún elemento con esa clase:\r\n            if(horaPrevia) {\r\n                //elimina la clase del elemento\r\n                horaPrevia.classList.remove('horas__hora--seleccionada');\r\n            }\r\n\r\n            //La API requiere como argumentos, dia_id y categoria_id, que obtendremos del objeto busqueda. \r\n            //Validar que no están vacios, antes de llamar a la funcion que consulta a la API.\r\n            //Si alguno de los values de las propiedades del Objeto busqueda, contiene '' string vacio, para el código\r\n            if(Object.values(busqueda).includes('')) {\r\n                return;\r\n            }\r\n\r\n            //llama a la función que consulta a la API\r\n            buscarEventos();\r\n        }\r\n\r\n        //función que consulta a la API APIEventos.php, para obtener eventos según la categoría y el día\r\n        async function buscarEventos() {\r\n\r\n            //deconstrucción de las propiedades de objeto busqueda, a dos variables con sus valores\r\n            const { dia, categoria_id} = busqueda\r\n            //define url para la consulta, incluyendo query string ? con los parametros para la API, \r\n            const url = `/api/eventos-horario?dia_id=${dia}&categoria_id=${categoria_id}`;\r\n           \r\n            //consulta fetch a la ulr de la API\r\n            const resultado = await fetch(url);\r\n            //obtiene los eventos como objetos json, del resultado de la consulta y\r\n            // los retorna como arreglo a la var eventos\r\n            const eventos = await resultado.json();\r\n\r\n            //llama metodo que obtiene las horas disponibles,\r\n            // enviando los eventos ya registrados, como argumento\r\n            obtenerHorasDisponibles(eventos);\r\n        }\r\n\r\n        //recibe los eventos ya registrados como parámetro,\r\n        //para obtener los li con las horas disponibles\r\n        function obtenerHorasDisponibles(eventos) {\r\n\r\n            //**Antes de obtener las horas disponibles, deshabilita todas las horas.\r\n            //selecciona todos los li, del elemento padre con id horas,\r\n            const listadoHoras = document.querySelectorAll('#horas li');\r\n            //itera el listado con todas las horas y les agrega la clase horas__hora--deshabilitada\r\n            listadoHoras.forEach(li => li.classList.add('horas__hora--deshabilitada'));\r\n\r\n            //**Comprobar los eventos ya registrados,\r\n            //mapea los eventos y genera un nuevo arreglo de horas, con la hora en hora_id, de cada evento,\r\n            //asigna el nuevo arreglo a horasTomadas\r\n            const horasTomadas = eventos.map( evento => evento.hora_id);\r\n\r\n            //listadoHoras es de tipo NodeList porque viene del querySelector,\r\n            //convertir el NodeList a arreglo con los li, para poder filtrarlo posteriormente\r\n            const listadoHorasArray = Array.from(listadoHoras);\r\n\r\n            //compara los li de listadoHorasArray con los li de horasTomadas, por sus atributos dataset.horaId,\r\n            //filtra los que NO ! coincidan, obteniendo un nuevo arreglo resultado con los li de la horas no tomadas\r\n            const resultado = listadoHorasArray.filter( li => !horasTomadas.includes(li.dataset.horaId))\r\n\r\n            //itera resultado con los li de las horas no reservadas y les quita la clase horas__hora--deshabilidada\r\n            resultado.forEach( li => li.classList.remove('horas__hora--deshabilitada'));\r\n\r\n            //selecciona, del elemento padre ul con id horas, \r\n            //, todos los elementos li, menos (:not) los que tienen la clase .horas__hora--deshabilitada \r\n            const horasDisponibles = document.querySelectorAll('#horas li:not(.horas__hora--deshabilitada)');\r\n            //itera horasDisponibles para asignarle un evento click y función, a cada elemento li (cada hora)\r\n            horasDisponibles.forEach(hora => hora.addEventListener('click', seleccionarHora))   \r\n        }\r\n\r\n        //se ejecuta con el evento (e) click, de cada hora del formulario\r\n        function seleccionarHora(e) {\r\n            //**deshabilitar la hora previa seleccionada, si hay nueva selección de hora\r\n            //asigna a horaPrevia, el elemento html cuya clase tenga '.horas__hora--selccionada'\r\n            const horaPrevia = document.querySelector('.horas__hora--seleccionada');\r\n            //si existe un elemento en horaPrevia:\r\n            if(horaPrevia) {\r\n                //elimina la clase del elemento (li)\r\n                horaPrevia.classList.remove('horas__hora--seleccionada')\r\n            }\r\n\r\n            //agrega la clase 'horas__hora--seleccionada,\r\n            //al elemento html (li) que dispara el evento (e) al click.\r\n            //clase agregada para dar estilos css\r\n            e.target.classList.add('horas__hora--seleccionada');\r\n\r\n            //al atributo value, del input oculto con name=\"hora_id\",\r\n            //(que hemos asisnado a la var inputHiddenHora),\r\n            //le agrega el valor del atributo personalizado (dataset) data-hora-id,\r\n            //del elemento li, que origina el evento (e), con click     \r\n            inputHiddenHora.value = e.target.dataset.horaId;\r\n\r\n            //asignar el value del dia seleccionado (checked), al value del input dia, oculto\r\n            inputHiddenDia.value = document.querySelector('[name=\"dia\"]:checked').value \r\n        }\r\n    }\r\n})();","//el código js irá dentro de una función IIFE (Inmediately Invoked Function Expresión), \r\n//esta función se autoejecuta inmediatamente despues de ser definida.\r\n//Se usa para evitar la contaminación del ámbito global y encapsular sus variables.\r\n(function() {\r\n\r\n    //seleciona elemento con id=ponentes\r\n    const ponentesInput = document.querySelector('#ponentes');\r\n\r\n    //valida si existen ponentes\r\n    if(ponentesInput) {\r\n        //array q almacenara temporalmente los ponetes consultados a la API\r\n        let ponentes = [];\r\n        //array a almacena temporalmente los ponentes filtrados\r\n        let ponentesFiltrados = [];\r\n\r\n        //seleciona elemento html cuya id es\r\n        const listadoPonentes = document.querySelector('#listado-ponentes');\r\n        //selecciona elemento html, el input oculto para el ponente\r\n        const ponenteHidden = document.querySelector('[name=\"ponente_id\"]');\r\n\r\n        //llama a funcion\r\n        obtenerPonentes();\r\n\r\n        //asigna un listener de evento tipo input y una función, al input\r\n        ponentesInput.addEventListener('input', buscarPonentes );\r\n\r\n\r\n        //comprueba si el value del input oculto ponenteHidden, tiene algún valor\r\n        if(ponenteHidden.value) {\r\n\r\n            //función IIFE que se autoejecuta, con una función anónima asyncrona, para poder usar await\r\n            (async() =>{\r\n                id = ponenteHidden.value;\r\n                //llama función para obtener el ponente, enviando el id\r\n                //await espera la respuesta de la función, antes de continuar con el código siguiente\r\n                const ponente = await obtenerPonente(id);\r\n                //deconstrucción de las propiedades nombre y apellido del objeto ponenete, en variables\r\n                const {nombre, apellido} = ponente;\r\n\r\n                //**Para insertar el ponente encontrado, en el HTML del DOM\r\n                //crea elemento html li\r\n                const ponenteDOM = document.createElement('LI');\r\n                //agregar clases al li\r\n                ponenteDOM.classList.add('listado-ponentes__ponente', 'listado-ponentes__ponente--seleccionado');\r\n                //agrega el valor de las variables, como texto al li\r\n                ponenteDOM.textContent = `${nombre} ${apellido}`;\r\n\r\n                //inserta el li, como hijo del ul de lisadoPonentes\r\n                listadoPonentes.appendChild(ponenteDOM);\r\n            })();\r\n\r\n        }\r\n\r\n        //obtiene ponentes a través de la API APIPonentes.php método index()\r\n        async function obtenerPonentes() { \r\n            //def url del endpoint de la API\r\n            const url = `/api/ponentes`;\r\n            //consulta con método fetch() a la API\r\n            const respuesta = await fetch(url);\r\n            //obtiene la info .json, de la respuesta de la consulta, en un arreglo de objetos json\r\n            //obtiene todos los datos (columnas) de todos los ponentes (registros)\r\n            const resultado = await respuesta.json(); \r\n            //llama función enviando el arreglo de objetos json resulado con toda la info\r\n            formatearPonentes(resultado);  \r\n        }\r\n\r\n        //obtiene ponente por su id, a través de la API APIPonentes.php método ponente()\r\n        async function obtenerPonente(id) { \r\n            //def url al endpoint de la API enviando el id recibido como parámetro\r\n            const url = `/api/ponente?id=${id}`;\r\n            //consulta con método fetch() a la API en la url\r\n            const respuesta = await fetch(url);\r\n            //obtiene la info .json, de la respuesta de la consulta, en un arreglo de objetos json\r\n            //obtiene todos los datos (columnas) del ponente por su id\r\n            const resultado = await respuesta.json(); \r\n            //retorna resultado\r\n            return resultado;\r\n        }\r\n\r\n\r\n        //obtiene un nuevo arreglo solo con la info necesaria, a partir del arrayPonentes recibido\r\n        function formatearPonentes(arrayPonentes = []) {\r\n            //mapea arrayPonentes y genera un nuevo array retornando solo con el id y nombre\r\n            //de cada ponente, asignandolo a la var array ponentes\r\n            ponentes = arrayPonentes.map( ponente => {\r\n                return {\r\n                    id: ponente.id,\r\n                    //.trim() elimina los espacios en blanco al inicio y al final del string\r\n                    nombre: `${ponente.nombre.trim()} ${ponente.apellido.trim()}`\r\n                }\r\n            })\r\n        }\r\n\r\n        // //función que recibe el evento input  \r\n        // function buscarPonentes(e) {\r\n        //     //asigna a busqueda, el value del elemento input (target), que dispara el evento e\r\n        //     let busqueda = e.target.value;\r\n\r\n        //     //si la longitud del valor de busqueda es > 3 \r\n        //     //(si en el input ya se han escrito más de 3 carácteres)\r\n        //     if(busqueda.length > 3) {\r\n        //         //crea un aexpresión regular con el valor de la var busqueda,\r\n        //         //la bandera \"i\" para que no tenga en cuenta si son máyusculas o minusculas\r\n        //         const expresion = new RegExp(busqueda, \"i\");\r\n        //         //genera un nuevor arrglo, filtrando el arreglo ponentes, y por cada ponente:\r\n        //         ponentesFiltrados = ponentes.filter( ponente => {\r\n        //             //busca en el nombre del ponente, convertido a minúsculas,\r\n        //             //la expresión regular o patrón, que contiene la var expresion,\r\n        //             // si lo contiene retorna 0, si no lo contiene retorna -1\r\n        //             if( ponente.nombre.toLowerCase().search(expresion) != -1 ) {\r\n        //                 //retorna el ponete o ponentes al arreglo ponentesFiltrados\r\n        //                 return ponente\r\n        //             }\r\n        //         });\r\n        //         console.log(ponentesFiltrados)\r\n        //     }\r\n        // }\r\n\r\n        //función que recibe el evento input  \r\n        function buscarPonentes(e) {\r\n\r\n            //asigna a busqueda, el value del elemento input (target), que dispara el evento e\r\n            const busqueda = e.target.value;\r\n        \r\n            //si la longitud del valor de busqueda es > 3 \r\n            //(si en el input ya se han escrito más de 3 carácteres)\r\n            if(busqueda.length > 3) {\r\n\r\n                //RegExp() crea un expresión regular con lo que contenga la var busqueda,\r\n                //normalize() convierte una cadena de caracteres en una forma normalizada,\r\n                //lo que significa que los caracteres con acentos son reemplazados con sus versiones sin acentos,\r\n                //la bandera \"i\" hace insensible a mayúsculas o minúsculas.\r\n                //TODO ESTO NOS PERMITIRÁ HACER UNA BÚSQUEDA SIN TENER EN CUENTA LOS ACENTOS Y LAS MAYUSCULAS\r\n                const expresion = new RegExp(busqueda.normalize('NFD').replace(/[\\u0300-\\u036f]/g, \"\"), \"i\");\r\n\r\n                //genera un nuevor arrglo, filtrando el arreglo ponentes, y por cada ponente:\r\n                ponentesFiltrados = ponentes.filter(ponente => {\r\n\r\n                    //busca la expresión regular o patrón, que contiene la var expresion,\r\n                    //en el nombre del ponente, normalizado y convertido a minúsculas,\r\n                    // si contiene la expresión retorna 0, si no la contiene retorna -1\r\n                    if(ponente.nombre.normalize('NFD').replace(/[\\u0300-\\u036f]/g, \"\").toLowerCase().search(expresion) != -1) {\r\n                        //como contiene la expresión, retorna ponente a ponentes filtrados\r\n                        return ponente\r\n                    }\r\n                })\r\n\r\n            } else {\r\n                ponentesFiltrados = []\r\n            }\r\n        \r\n            //llama función, una vez filtrados los ponentes buscados\r\n            mostrarPonentes();\r\n        }\r\n\r\n        function mostrarPonentes() {\r\n\r\n            //Limpiar el listado de ponentes.\r\n            //mientras listado ponentes tenga un elemento hijo\r\n            while(listadoPonentes.firstChild) {\r\n                //eliminar el elemento hijo\r\n                listadoPonentes.removeChild(listadoPonentes.firstChild);\r\n            }\r\n\r\n            //si ponentesFiltrados contiene algo:\r\n            if(ponentesFiltrados.length > 0) {\r\n\r\n                //itera los ponentes filtrados encotrados y por cada ponente:\r\n                ponentesFiltrados.forEach( ponente => {\r\n                    //crea elemento html li y lo asigna a ponentHTML\r\n                    const ponenteHTML = document.createElement('LI');\r\n                    //agrega class al elemento li\r\n                    ponenteHTML.classList.add('listado-ponentes__ponente');\r\n                    //agrega al contenido del li, el nombre del ponente filtrado\r\n                    ponenteHTML.textContent = ponente.nombre;\r\n                    //agrega el id del poenente, al atributo dataset ponenteId al li\r\n                    ponenteHTML.dataset.ponenteId = ponente.id\r\n                    //agrega evento onclick al ponente y metodo a ejecutar\r\n                    ponenteHTML.onclick =  seleccionarPonente;\r\n\r\n                    //Agregar el o los li al DOM\r\n                    listadoPonentes.appendChild(ponenteHTML);\r\n                })\r\n\r\n            //si ponentesFiltrados NO contiene nada\r\n            } else {\r\n                //crea elemento html p\r\n                const noResultados = document.createElement('P');\r\n                noResultados.classList.add('listado-ponentes__no-resultado');\r\n                noResultados.textContent = 'No Hay Resultados en tu búsquda';\r\n\r\n                //Agregar el P párrafo al DOM\r\n                listadoPonentes.appendChild(noResultados);\r\n             }\r\n        }\r\n\r\n        function seleccionarPonente(e) {\r\n            //selecciona el elemento html que dispara el evento\r\n            const ponente = e.target\r\n\r\n            //**eliminar la clase --seleccionado, por si ya la tiene asignada\r\n            //selecciona elemento html con clase = , puede que ya exista o no\r\n            const ponentePrevio = document.querySelector('.listado-ponentes__ponente--seleccionado');\r\n            //si ya existe un elemento con esa clase, se la elimina\r\n            if(ponentePrevio) {\r\n                ponentePrevio.classList.remove('listado-ponentes__ponente--seleccionado');\r\n            }\r\n\r\n            //agrega clase al elemento html\r\n            ponente.classList.add('listado-ponentes__ponente--seleccionado');\r\n\r\n            //agrega el valor del atributo dataset ponenteId del ponente seleccionado, \r\n            // al atributo value del input poneneteHidden\r\n            ponenteHidden.value = ponente.dataset.ponenteId\r\n        }\r\n    }\r\n\r\n})();","//el código js irá dentro de una función IIFE (Inmediately Invoked Function Expresión), \r\n//esta función se autoejecuta inmediatamente despues de ser definida.\r\n//Se usa para evitar la contaminación del ámbito global y encapsular sus variables.\r\n(function() {\r\n    //selecciona el elemento con id #tags_input y la asigna a la var tagsInput\r\n    const tagsInput = document.querySelector('#tags_input');\r\n    \r\n    //si el elemento tagsInput existe, se ejecuta el código\r\n    if(tagsInput) {\r\n        \r\n        //arreglo almacena las etiquetas tecleadas en el input, cuando se teclee ,\r\n        let tags = [];\r\n\r\n        //selecciona elemento html con id #tags, donde se mostraran los tags\r\n        const tagsDiv = document.querySelector('#tags');\r\n\r\n        //selecciona elemento html del form, con el atributo name=\"tags\"\r\n        //es el input hidden (oculto) del formulario agregar ponentes\r\n        const tagsInputHidden = document.querySelector('[name=\"tags\"]');\r\n\r\n        //**Recuperar los tags del value del input hidden (oculto)\r\n        //si el atributo value de elemento tagsInputHidden, contiene info\r\n        if(tagsInputHidden.value !== '') {\r\n            //extrae los valores separados por ',' del string, \r\n            //los convierte en arreglo y los asigna a tags\r\n            tags = tagsInputHidden.value.split(',');\r\n            //llama metodo que muestra los tags en el formulario\r\n            mostrarTags()\r\n        }\r\n\r\n        //Escuchar cambios en el input, cuando se teclee algo, ejecuta función\r\n        tagsInput.addEventListener('keypress', guardarTag);\r\n\r\n        //función que recibe el evento escuchado en e\r\n        function guardarTag(e) {\r\n            //si el código de la tecla que dispara el evento e, es 44\r\n            //significa que la tecla es una coma ,\r\n            if(e.keyCode === 44) {\r\n\r\n                //validar si se teclean espacios en blanco, o no se ha tecleado nada,\r\n                //no seguir ejecutando el código\r\n                if(e.target.value.trim() === '' || e.target.value < 1) {\r\n                    return\r\n                }\r\n\r\n                //cuando se ha pulsado la coma, evita la acción por defecto del evento e\r\n                // que es escribir la coma, para que la coma , no se muestre en el input\r\n                e.preventDefault();\r\n\r\n                //como se ha pulsado la tecla coma ,\r\n                //se genera un nuevo arreglo que toma copia del arreglo tags ...tags,\r\n                //agrega el valor de lo que se haya tecleado en el input (e.target.value),\r\n                //eliminando los valores en blanco con .trim() y lo reasigna al arreglo tags\r\n                tags = [...tags, e.target.value.trim()];\r\n                \r\n                //limpia el contenido del input tagsInput, tras pulsar la coma ,\r\n                tagsInput.value = '';\r\n\r\n                //llama función mostra los tags\r\n                mostrarTags();\r\n            }\r\n        }\r\n\r\n        //Muestra cada tag en el formulario\r\n        function mostrarTags() {\r\n            //agrega al div un string vacio, para limpiar\r\n            tagsDiv.textContent = '';\r\n\r\n            //itera el arreglo tags con las etiquetas introducidas\r\n            //y por cada etiqueta en tag\r\n            tags.forEach( tag => {\r\n                //crea un elemento LI y lo asigna a etiqueta\r\n                const etiqueta = document.createElement('LI');\r\n                //agrega la clase formulario__tag al elemento LI\r\n                etiqueta.classList.add('formulario__tag');\r\n                //agrega el valor (string) de la etiqueta iterada, en tag, al LI etiqueta\r\n                etiqueta.textContent = tag;\r\n                //asigna evento dobleclick a la etiqueta, que ejecutará la función eliminarTag\r\n                etiqueta.ondblclick = eliminarTag\r\n                //inserta el LI etiqueta, como hijo del div con id #tags\r\n                tagsDiv.appendChild(etiqueta); \r\n            })\r\n\r\n            //llama la función que asigna, el tag mostrado, al input hidden (oculto)\r\n            actualizarInputHidden()\r\n        }\r\n\r\n        //elimina del DOM y del arreglo tags, el tag recibido como evento dobleclick en e,\r\n        function eliminarTag(e) {\r\n            //elimina del DOM, el elemento (tag) que origna el evento e, el e.target\r\n            e.target.remove()\r\n            //filtra y obtiene cada tag sobre el que no se haya aplicado el e.target,\r\n            //los no eliminados y los reasigna al arreglo tags\r\n            tags = tags.filter(tag => tag !== e.target.textContent)\r\n            //llama método que asigna los tags al value del input hidden, para la DB\r\n            actualizarInputHidden()\r\n        } \r\n\r\n        //función que asigna cada tag, al value de input hidden (oculto)\r\n        //para actualizarlos en la DB\r\n        function actualizarInputHidden() {\r\n            //asigna al value del input hidden, el arreglo tag convertido a string\r\n            tagsInputHidden.value = tags.toString();\r\n        }\r\n    }\r\n\r\n})();\r\n"]}